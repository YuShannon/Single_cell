# block 3-23 and CTB_4 adjusted filepaths

```{r}
#BiocManager::install("ComplexHeatmap")
library(ComplexHeatmap)
BiocManager::install("readr")
library(readr)
library(dplyr)

# setwd("C:/Users/Team Knowhow/OneDrive - The University of Manchester/MScRP2/R/Third_trimester/yang_mitoxall")
# 
# #Load expression data
# X_data <- read.csv("C:/Users/Team Knowhow/OneDrive - The University of Manchester/MScRP2/R/Third_trimester/yang_X.csv",row.names=1)
# cell_obs<-read.csv("C:/Users/Team Knowhow/OneDrive - The University of Manchester/MScRP2/R//Third_trimester/yang_obs.csv",row.names=1)
# gene_var<-read.csv("C:/Users/Team Knowhow/OneDrive - The University of Manchester/MScRP2/R/Third_trimester/yang_var.csv",row.names=1)

setwd("C:/Users/shann/OneDrive - The University of Manchester/MScRP2/R/Third_trimester/yang_mitoxall")

#Load expression data
X_data <- read.csv("C:/Users/shann/OneDrive - The University of Manchester/MScRP2/R/Third_trimester/yang_X.csv",row.names=1)
cell_obs<-read.csv("C:/Users/shann/OneDrive - The University of Manchester/MScRP2/R//Third_trimester/yang_obs.csv",row.names=1)
gene_var<-read.csv("C:/Users/shann/OneDrive - The University of Manchester/MScRP2/R/Third_trimester/yang_var.csv",row.names=1)
```

# CTB_1 #

```{r}

#### CTB_1 ####  
set.seed(3)

# Filter cells by cluster name
CTB_1 <- cell_obs[cell_obs$unique_cell_type == "CTB_1", ]

# subset X_data by cell IDs only in CTB_1
CTB_1_X <- X_data[rownames(X_data) %in% rownames(CTB_1), ]

# calculate standard deviation for each column (gene) in CTB_1 expression data
sd.scores0<-apply(CTB_1_X,2,sd) #2 = selects columns not rows
CTB_1_X_sd<-CTB_1_X[,which(sd.scores0>0)] # only keep genes with SD>0; removes genes with no variation

# idenfity MT genes that are also velocity genes
CTB_1_mito <- rownames(gene_var)[gene_var$mito_gene == "True"]

# Run the correlation
CTB_1_cor_data <- cor(CTB_1_X_sd[, intersect(CTB_1_mito, colnames(CTB_1_X_sd))], # mito genes   
                      CTB_1_X_sd[, !colnames(CTB_1_X_sd) %in% CTB_1_mito]) # non-mito genes

#Binarise correlation values using sd of correlation matrix
bin_CTB_1 <-abs(CTB_1_cor_data) # takes absolute value of correlation matrix
bin_CTB_1[which(bin_CTB_1>sd(CTB_1_cor_data))]<-1 # binarises values, where values greater than SD of correlation matrix are set to 1
bin_CTB_1[which(bin_CTB_1!=1)]<-0 # all other values are set to 0; this creates the hypergraph incidence matrix

#Matrix multiplication to generate hypergraph adjacency matrix
hyp_CTB_1<-bin_CTB_1 %*% t(bin_CTB_1) # adjacency matrix; multiplies the matrix by its transpose

#ranking
CTB_1_rowsum_result<- rowSums(hyp_CTB_1) # sum each row in adjacency matrix
hist(CTB_1_rowsum_result) # histogram of row sums to visualise distribution
CTB_1_row_sums <- as.data.frame(CTB_1_rowsum_result) # converts row sums vector to a data frame

colnames(CTB_1_row_sums)[1] <- "rowsum" # rename column to rowsum
CTB_1_row_sums$unique_cell_type <- "CTB_1"  # adds a column with cell type label
CTB_1_row_sums$rank <- rank(CTB_1_row_sums$rowsum, ties.method = "average") # ranks genes based on row sums, using average ranking for tied values 
CTB_1_row_sums$norm_rank <- CTB_1_row_sums$rank / nrow(CTB_1_row_sums) # normalises ranks by dividing by total number of rows, creating a value between 0 and 1

CTB_1_row_sums <- CTB_1_row_sums[order(CTB_1_row_sums$rank, decreasing = TRUE), ] # sorts data frame in descending order of rank

write.csv(CTB_1_row_sums, "C:/Users/Team Knowhow/OneDrive - The University of Manchester/MScRP2/R/Third_trimester/yang_mitoxall/CTB_1_row_sums_results_ranked.csv", row.names=TRUE)

## plotting the heatmaps ##

#initially plot without row_split = 2,column_split = 2, so you can see your data
hm_CTB_1_1<-Heatmap(hyp_CTB_1, heatmap_width = unit(15, "cm"),heatmap_height = unit(15, "cm"),show_row_names = FALSE, show_column_names = FALSE, heatmap_legend_param = list(title = "Adjacency Score"), use_raster = T) #plot the heatmap, specifying the number of column and row clusters to split it into, raster improves performance at cost of resolution
draw(hm_CTB_1_1) #above comand will save the output to an object. use this command to plot the heatmap. plot(hm_FGR_1) also works

#then plot again when you can select the clusters in the data (represented by higher value colours based on the heatmap colourscale)
hm_CTB_1_2<-Heatmap(hyp_CTB_1, heatmap_width = unit(15, "cm"),heatmap_height = unit(15, "cm"),show_row_names = FALSE, show_column_names = FALSE, row_split = 2, column_split = 2, heatmap_legend_param = list(title = "Adjacency Score"),use_raster = T) #plot the heatmap, specifying the number of column and row clusters to split it into, raster improves performance at cost of resolution
ht <- draw(hm_CTB_1_2) #above comand will save the output to an object. 
row_order_CTB_1_2 <- row_order(ht)

# Save the heatmap as a PNG
png("C:/Users/Team Knowhow/OneDrive - The University of Manchester/MScRP2/R/Third_trimester/yang_mitoxall/CTB_1_1_heatmap.png", width = 2300, height = 2000, res = 300)  
draw(hm_CTB_1_1)
dev.off()

# Save the heatmap as a PNG
png("C:/Users/Team Knowhow/OneDrive - The University of Manchester/MScRP2/R/Third_trimester/yang_mitoxall/CTB_1_2_heatmap.png", width = 2300, height = 2000, res = 300)  
draw(hm_CTB_1_2)
dev.off()
```

```{r}
## calculating the galois for the cluster ##

# extract row orders
row_order_CTB_1_2<-row_order(ht) #extract the row order from the heatmap into a list; each list element represents a cluster from the image and the number represents the row from the original data, arranged in the same order as the heatmap.
CTB_1_clust<-rownames(hyp_CTB_1)[row_order_CTB_1_2[[1]]] #extract row names from row numbers extracted in step above.

## calculate the galois correspondacnce
CTB_1_gal<-bin_CTB_1[match(CTB_1_clust,rownames(bin_CTB_1)),] #subset the original binary matrix to the rows from the cluster defined above

gal_98<-CTB_1_gal[,colSums(CTB_1_gal)>quantile(colSums(CTB_1_gal), 0.98)]
write.csv(gal_98, file = "C:/Users/Team Knowhow/OneDrive - The University of Manchester/MScRP2/R/Third_trimester/yang_mitoxall/galois/CTB_1_gal_98.csv", row.names = TRUE)
```

# CTB_2 #

```{r}

#### CTB_2 ####  
set.seed(3)

# Filter cells by cluster name
CTB_2 <- cell_obs[cell_obs$unique_cell_type == "CTB_2", ]

# subset X_data by cell IDs only in CTB_2
CTB_2_X <- X_data[rownames(X_data) %in% rownames(CTB_2), ]

# calculate standard deviation for each column (gene) in CTB_2 expression data
sd.scores0<-apply(CTB_2_X,2,sd) #2 = selects columns not rows
CTB_2_X_sd<-CTB_2_X[,which(sd.scores0>0)] # only keep genes with SD>0; removes genes with no variation

# idenfity MT genes that are also velocity genes
CTB_2_mito <- rownames(gene_var)[gene_var$mito_gene == "True"]

# Run the correlation
CTB_2_cor_data <- cor(CTB_2_X_sd[, intersect(CTB_2_mito, colnames(CTB_2_X_sd))], # mito genes   
                      CTB_2_X_sd[, !colnames(CTB_2_X_sd) %in% CTB_2_mito]) # non-mito genes

#Binarise correlation values using sd of correlation matrix
bin_CTB_2 <-abs(CTB_2_cor_data) # takes absolute value of correlation matrix
bin_CTB_2[which(bin_CTB_2>sd(CTB_2_cor_data))]<-1 # binarises values, where values greater than SD of correlation matrix are set to 1
bin_CTB_2[which(bin_CTB_2!=1)]<-0 # all other values are set to 0; this creates the hypergraph incidence matrix

#Matrix multiplication to generate hypergraph adjacency matrix
hyp_CTB_2<-bin_CTB_2 %*% t(bin_CTB_2) # adjacency matrix; multiplies the matrix by its transpose

#ranking
CTB_2_rowsum_result<- rowSums(hyp_CTB_2) # sum each row in adjacency matrix
hist(CTB_2_rowsum_result) # histogram of row sums to visualise distribution
CTB_2_row_sums <- as.data.frame(CTB_2_rowsum_result) # converts row sums vector to a data frame

colnames(CTB_2_row_sums)[1] <- "rowsum" # rename column to rowsum
CTB_2_row_sums$unique_cell_type <- "CTB_2"  # adds a column with cell type label
CTB_2_row_sums$rank <- rank(CTB_2_row_sums$rowsum, ties.method = "average") # ranks genes based on row sums, using average ranking for tied values 
CTB_2_row_sums$norm_rank <- CTB_2_row_sums$rank / nrow(CTB_2_row_sums) # normalises ranks by dividing by total number of rows, creating a value between 0 and 1

CTB_2_row_sums <- CTB_2_row_sums[order(CTB_2_row_sums$rank, decreasing = TRUE), ] # sorts data frame in descending order of rank

write.csv(CTB_2_row_sums, "C:/Users/Team Knowhow/OneDrive - The University of Manchester/MScRP2/R/Third_trimester/yang_mitoxall/CTB_2_row_sums_results_ranked.csv", row.names=TRUE)

## plotting the heatmaps ##

#initially plot without row_split = 2,column_split = 2, so you can see your data
hm_CTB_2_1<-Heatmap(hyp_CTB_2, heatmap_width = unit(15, "cm"),heatmap_height = unit(15, "cm"),show_row_names = FALSE, show_column_names = FALSE, heatmap_legend_param = list(title = "Adjacency Score"), use_raster = T) #plot the heatmap, specifying the number of column and row clusters to split it into, raster improves performance at cost of resolution
draw(hm_CTB_2_1) #above comand will save the output to an object. use this command to plot the heatmap. plot(hm_FGR_1) also works

#then plot again when you can select the clusters in the data (represented by higher value colours based on the heatmap colourscale)
hm_CTB_2_2<-Heatmap(hyp_CTB_2, heatmap_width = unit(15, "cm"),heatmap_height = unit(15, "cm"),show_row_names = FALSE, show_column_names = FALSE, row_split = 2, column_split = 2, heatmap_legend_param = list(title = "Adjacency Score"),use_raster = T) #plot the heatmap, specifying the number of column and row clusters to split it into, raster improves performance at cost of resolution
ht <- draw(hm_CTB_2_2) #above comand will save the output to an object. 
row_order_CTB_2_2 <- row_order(ht)

# Save the heatmap as a PNG
png("C:/Users/Team Knowhow/OneDrive - The University of Manchester/MScRP2/R/Third_trimester/yang_mitoxall/CTB_2_1_heatmap.png", width = 2300, height = 2000, res = 300)  # 300 dpi for publication quality
draw(hm_CTB_2_1)
dev.off()

# Save the heatmap as a PNG
png("C:/Users/Team Knowhow/OneDrive - The University of Manchester/MScRP2/R/Third_trimester/yang_mitoxall/CTB_2_2_heatmap.png", width = 2300, height = 2000, res = 300)  # 300 dpi for publication quality
draw(hm_CTB_2_2)
dev.off()
```

```{r}
## calculating the galois for the cluster ##

# extract row orders
row_order_CTB_2_2<-row_order(ht) #extract the row order from the heatmap into a list; each list element represents a cluster from the image and the number represents the row from the original data, arranged in the same order as the heatmap.
CTB_2_clust<-rownames(hyp_CTB_2)[row_order_CTB_2_2[[2]]] #extract row names from row numbers extracted in step above.

## calculate the galois correspondacnce
CTB_2_gal<-bin_CTB_2[match(CTB_2_clust,rownames(bin_CTB_2)),] #subset the original binary matrix to the rows from the cluster defined above

gal_98<-CTB_2_gal[,colSums(CTB_2_gal)>quantile(colSums(CTB_2_gal), 0.98)]
write.csv(gal_98, file = "C:/Users/Team Knowhow/OneDrive - The University of Manchester/MScRP2/R/Third_trimester/yang_mitoxall/galois/CTB_2_gal_98.csv", row.names = TRUE)
```

# CTB_3 # 

```{r}

#### CTB_3 ####  
set.seed(3)

# Filter cells by cluster name
CTB_3 <- cell_obs[cell_obs$unique_cell_type == "CTB_3", ]

# subset X_data by cell IDs only in CTB_3
CTB_3_X <- X_data[rownames(X_data) %in% rownames(CTB_3), ]

# calculate standard deviation for each column (gene) in CTB_3 expression data
sd.scores0<-apply(CTB_3_X,2,sd) #2 = selects columns not rows
CTB_3_X_sd<-CTB_3_X[,which(sd.scores0>0)] # only keep genes with SD>0; removes genes with no variation

# idenfity MT genes that are also velocity genes
CTB_3_mito <- rownames(gene_var)[gene_var$mito_gene == "True"]

# Run the correlation
CTB_3_cor_data <- cor(CTB_3_X_sd[, intersect(CTB_3_mito, colnames(CTB_3_X_sd))], # mito genes   
                      CTB_3_X_sd[, !colnames(CTB_3_X_sd) %in% CTB_3_mito]) # non-mito genes

#Binarise correlation values using sd of correlation matrix
bin_CTB_3 <-abs(CTB_3_cor_data) # takes absolute value of correlation matrix
bin_CTB_3[which(bin_CTB_3>sd(CTB_3_cor_data))]<-1 # binarises values, where values greater than SD of correlation matrix are set to 1
bin_CTB_3[which(bin_CTB_3!=1)]<-0 # all other values are set to 0; this creates the hypergraph incidence matrix

#Matrix multiplication to generate hypergraph adjacency matrix
hyp_CTB_3<-bin_CTB_3 %*% t(bin_CTB_3) # adjacency matrix; multiplies the matrix by its transpose

#ranking
CTB_3_rowsum_result<- rowSums(hyp_CTB_3) # sum each row in adjacency matrix
hist(CTB_3_rowsum_result) # histogram of row sums to visualise distribution
CTB_3_row_sums <- as.data.frame(CTB_3_rowsum_result) # converts row sums vector to a data frame

colnames(CTB_3_row_sums)[1] <- "rowsum" # rename column to rowsum
CTB_3_row_sums$unique_cell_type <- "CTB_3"  # adds a column with cell type label
CTB_3_row_sums$rank <- rank(CTB_3_row_sums$rowsum, ties.method = "average") # ranks genes based on row sums, using average ranking for tied values 
CTB_3_row_sums$norm_rank <- CTB_3_row_sums$rank / nrow(CTB_3_row_sums) # normalises ranks by dividing by total number of rows, creating a value between 0 and 1

CTB_3_row_sums <- CTB_3_row_sums[order(CTB_3_row_sums$rank, decreasing = TRUE), ] # sorts data frame in descending order of rank

write.csv(CTB_3_row_sums, "C:/Users/Team Knowhow/OneDrive - The University of Manchester/MScRP2/R/Third_trimester/yang_mitoxall/CTB_3_row_sums_results_ranked.csv", row.names=TRUE)

## plotting the heatmaps ##

#initially plot without row_split = 2,column_split = 2, so you can see your data
hm_CTB_3_1<-Heatmap(hyp_CTB_3, heatmap_width = unit(15, "cm"),heatmap_height = unit(15, "cm"),show_row_names = FALSE, show_column_names = FALSE, heatmap_legend_param = list(title = "Adjacency Score"), use_raster = T) #plot the heatmap, specifying the number of column and row clusters to split it into, raster improves performance at cost of resolution
draw(hm_CTB_3_1) #above comand will save the output to an object. use this command to plot the heatmap. plot(hm_FGR_1) also works

#then plot again when you can select the clusters in the data (represented by higher value colours based on the heatmap colourscale)
hm_CTB_3_2<-Heatmap(hyp_CTB_3, heatmap_width = unit(15, "cm"),heatmap_height = unit(15, "cm"),show_row_names = FALSE, show_column_names = FALSE, row_split = 2, column_split = 2, heatmap_legend_param = list(title = "Adjacency Score"),use_raster = T) #plot the heatmap, specifying the number of column and row clusters to split it into, raster improves performance at cost of resolution
ht <- draw(hm_CTB_3_2) #above comand will save the output to an object. 
row_order_CTB_3_2 <- row_order(ht)

# Save the heatmap as a PNG
png("C:/Users/Team Knowhow/OneDrive - The University of Manchester/MScRP2/R/Third_trimester/yang_mitoxall/CTB_3_1_heatmap.png", width = 2300, height = 2000, res = 300)  # 300 dpi for publication quality
draw(hm_CTB_3_1)
dev.off()

# Save the heatmap as a PNG
png("C:/Users/Team Knowhow/OneDrive - The University of Manchester/MScRP2/R/Third_trimester/yang_mitoxall/CTB_3_2_heatmap.png", width = 2300, height = 2000, res = 300)  # 300 dpi for publication quality
draw(hm_CTB_3_2)
dev.off()
```

```{r}
## calculating the galois for the cluster ##

# extract row orders
row_order_CTB_3_2<-row_order(ht) #extract the row order from the heatmap into a list; each list element represents a cluster from the image and the number represents the row from the original data, arranged in the same order as the heatmap.
CTB_3_clust<-rownames(hyp_CTB_3)[row_order_CTB_3_2[[1]]] #extract row names from row numbers extracted in step above.

## calculate the galois correspondacnce
CTB_3_gal<-bin_CTB_3[match(CTB_3_clust,rownames(bin_CTB_3)),] #subset the original binary matrix to the rows from the cluster defined above

gal_98<-CTB_3_gal[,colSums(CTB_3_gal)>quantile(colSums(CTB_3_gal), 0.98)]
write.csv(gal_98, file = "C:/Users/Team Knowhow/OneDrive - The University of Manchester/MScRP2/R/Third_trimester/yang_mitoxall/galois/CTB_3_gal_98.csv", row.names = TRUE)
```

# CTB_4 #

```{r}

#### CTB_4 ####  
set.seed(3)

# Filter cells by cluster name
CTB_4 <- cell_obs[cell_obs$unique_cell_type == "CTB_4", ]

# subset X_data by cell IDs only in CTB_4
CTB_4_X <- X_data[rownames(X_data) %in% rownames(CTB_4), ]

# calculate standard deviation for each column (gene) in CTB_4 expression data
sd.scores0<-apply(CTB_4_X,2,sd) #2 = selects columns not rows
CTB_4_X_sd<-CTB_4_X[,which(sd.scores0>0)] # only keep genes with SD>0; removes genes with no variation

# idenfity MT genes that are also velocity genes
CTB_4_mito <- rownames(gene_var)[gene_var$mito_gene == "True"]

# Run the correlation
CTB_4_cor_data <- cor(CTB_4_X_sd[, intersect(CTB_4_mito, colnames(CTB_4_X_sd))], # mito genes   
                      CTB_4_X_sd[, !colnames(CTB_4_X_sd) %in% CTB_4_mito]) # non-mito genes

#Binarise correlation values using sd of correlation matrix
bin_CTB_4 <-abs(CTB_4_cor_data) # takes absolute value of correlation matrix
bin_CTB_4[which(bin_CTB_4>sd(CTB_4_cor_data))]<-1 # binarises values, where values greater than SD of correlation matrix are set to 1
bin_CTB_4[which(bin_CTB_4!=1)]<-0 # all other values are set to 0; this creates the hypergraph incidence matrix

#Matrix multiplication to generate hypergraph adjacency matrix
hyp_CTB_4<-bin_CTB_4 %*% t(bin_CTB_4) # adjacency matrix; multiplies the matrix by its transpose

#ranking
CTB_4_rowsum_result<- rowSums(hyp_CTB_4) # sum each row in adjacency matrix
hist(CTB_4_rowsum_result) # histogram of row sums to visualise distribution
CTB_4_row_sums <- as.data.frame(CTB_4_rowsum_result) # converts row sums vector to a data frame

colnames(CTB_4_row_sums)[1] <- "rowsum" # rename column to rowsum
CTB_4_row_sums$unique_cell_type <- "CTB_4"  # adds a column with cell type label
CTB_4_row_sums$rank <- rank(CTB_4_row_sums$rowsum, ties.method = "average") # ranks genes based on row sums, using average ranking for tied values 
CTB_4_row_sums$norm_rank <- CTB_4_row_sums$rank / nrow(CTB_4_row_sums) # normalises ranks by dividing by total number of rows, creating a value between 0 and 1

CTB_4_row_sums <- CTB_4_row_sums[order(CTB_4_row_sums$rank, decreasing = TRUE), ] # sorts data frame in descending order of rank

# write.csv(CTB_4_row_sums, "C:/Users/Team Knowhow/OneDrive - The University of Manchester/MScRP2/R/Third_trimester/yang_mitoxall/CTB_4_row_sums_results_ranked.csv", row.names=TRUE)

## plotting the heatmaps ##

#initially plot without row_split = 2,column_split = 2, so you can see your data
hm_CTB_4_1<-Heatmap(hyp_CTB_4, heatmap_width = unit(15, "cm"),heatmap_height = unit(15, "cm"),show_row_names = FALSE, show_column_names = FALSE, heatmap_legend_param = list(title = "Adjacency Score"), use_raster = T) #plot the heatmap, specifying the number of column and row clusters to split it into, raster improves performance at cost of resolution
draw(hm_CTB_4_1) #above comand will save the output to an object. use this command to plot the heatmap. plot(hm_FGR_1) also works

#then plot again when you can select the clusters in the data (represented by higher value colours based on the heatmap colourscale)
hm_CTB_4_2<-Heatmap(hyp_CTB_4, heatmap_width = unit(15, "cm"),heatmap_height = unit(15, "cm"),show_row_names = FALSE, show_column_names = FALSE, row_split = 2, column_split = 2, heatmap_legend_param = list(title = "Adjacency Score"),use_raster = T) #plot the heatmap, specifying the number of column and row clusters to split it into, raster improves performance at cost of resolution
ht <- draw(hm_CTB_4_2) #above comand will save the output to an object. 
row_order_CTB_4_2 <- row_order(ht)

# # Save the heatmap as a PNG
# png("C:/Users/Team Knowhow/OneDrive - The University of Manchester/MScRP2/R/Third_trimester/yang_mitoxall/CTB_4_1_heatmap.png", width = 2300, height = 2000, res = 300)  # 300 dpi for publication quality
# draw(hm_CTB_4_1)
# dev.off()
# 
# # Save the heatmap as a PNG
# png("C:/Users/Team Knowhow/OneDrive - The University of Manchester/MScRP2/R/Third_trimester/yang_mitoxall/CTB_4_2_heatmap.png", width = 2300, height = 2000, res = 300)  # 300 dpi for publication quality
# draw(hm_CTB_4_2)
# dev.off()

# Save the heatmap as a PNG
png("C:/Users/shann/OneDrive - The University of Manchester/MScRP2/R/Third_trimester/yang_mitoxall/CTB_4_1_heatmapv2.png", width = 2300, height = 2000, res = 300)  # 300 dpi for publication quality
draw(hm_CTB_4_1)
dev.off()

# Save the heatmap as a PNG
png("C:/Users/shann/OneDrive - The University of Manchester/MScRP2/R/Third_trimester/yang_mitoxall/CTB_4_2_heatmapv2.png", width = 2300, height = 2000, res = 300)  # 300 dpi for publication quality
draw(hm_CTB_4_2)
dev.off()

#
```

```{r}
## calculating the galois for the cluster ##

# extract row orders
row_order_CTB_4_2<-row_order(ht) #extract the row order from the heatmap into a list; each list element represents a cluster from the image and the number represents the row from the original data, arranged in the same order as the heatmap.
CTB_4_clust<-rownames(hyp_CTB_4)[row_order_CTB_4_2[[1]]] #extract row names from row numbers extracted in step above.

## calculate the galois correspondacnce
CTB_4_gal<-bin_CTB_4[match(CTB_4_clust,rownames(bin_CTB_4)),] #subset the original binary matrix to the rows from the cluster defined above

# gal_98<-CTB_4_gal[,colSums(CTB_4_gal)>quantile(colSums(CTB_4_gal), 0.98)]
# write.csv(gal_98, file = "C:/Users/Team Knowhow/OneDrive - The University of Manchester/MScRP2/R/Third_trimester/yang_mitoxall/galois/CTB_4_gal_98.csv", row.names = TRUE)

gal_greaterequal98<-CTB_4_gal[, colSums(CTB_4_gal)>=quantile(colSums(CTB_4_gal), 0.98)]
write.csv(gal_98, file = "C:/Users/shann/OneDrive - The University of Manchester/MScRP2/R/Third_trimester/yang_mitoxall/galois/CTB_4_galgreaterequal98.csv", row.names = TRUE)
```

# CTB_5 #

```{r}

#### CTB_5 ####  
set.seed(3)

# Filter cells by cluster name
CTB_5 <- cell_obs[cell_obs$unique_cell_type == "CTB_5", ]

# subset X_data by cell IDs only in CTB_5
CTB_5_X <- X_data[rownames(X_data) %in% rownames(CTB_5), ]

# calculate standard deviation for each column (gene) in CTB_5 expression data
sd.scores0<-apply(CTB_5_X,2,sd) #2 = selects columns not rows
CTB_5_X_sd<-CTB_5_X[,which(sd.scores0>0)] # only keep genes with SD>0; removes genes with no variation

# idenfity MT genes that are also velocity genes
CTB_5_mito <- rownames(gene_var)[gene_var$mito_gene == "True"]

# Run the correlation
CTB_5_cor_data <- cor(CTB_5_X_sd[, intersect(CTB_5_mito, colnames(CTB_5_X_sd))], # mito genes   
                      CTB_5_X_sd[, !colnames(CTB_5_X_sd) %in% CTB_5_mito]) # non-mito genes

#Binarise correlation values using sd of correlation matrix
bin_CTB_5 <-abs(CTB_5_cor_data) # takes absolute value of correlation matrix
bin_CTB_5[which(bin_CTB_5>sd(CTB_5_cor_data))]<-1 # binarises values, where values greater than SD of correlation matrix are set to 1
bin_CTB_5[which(bin_CTB_5!=1)]<-0 # all other values are set to 0; this creates the hypergraph incidence matrix

#Matrix multiplication to generate hypergraph adjacency matrix
hyp_CTB_5<-bin_CTB_5 %*% t(bin_CTB_5) # adjacency matrix; multiplies the matrix by its transpose

#ranking
CTB_5_rowsum_result<- rowSums(hyp_CTB_5) # sum each row in adjacency matrix
hist(CTB_5_rowsum_result) # histogram of row sums to visualise distribution
CTB_5_row_sums <- as.data.frame(CTB_5_rowsum_result) # converts row sums vector to a data frame

colnames(CTB_5_row_sums)[1] <- "rowsum" # rename column to rowsum
CTB_5_row_sums$unique_cell_type <- "CTB_5"  # adds a column with cell type label
CTB_5_row_sums$rank <- rank(CTB_5_row_sums$rowsum, ties.method = "average") # ranks genes based on row sums, using average ranking for tied values 
CTB_5_row_sums$norm_rank <- CTB_5_row_sums$rank / nrow(CTB_5_row_sums) # normalises ranks by dividing by total number of rows, creating a value between 0 and 1

CTB_5_row_sums <- CTB_5_row_sums[order(CTB_5_row_sums$rank, decreasing = TRUE), ] # sorts data frame in descending order of rank

write.csv(CTB_5_row_sums, "C:/Users/Team Knowhow/OneDrive - The University of Manchester/MScRP2/R/Third_trimester/yang_mitoxall/CTB_5_row_sums_results_ranked.csv", row.names=TRUE)

## plotting the heatmaps ##

#initially plot without row_split = 2,column_split = 2, so you can see your data
hm_CTB_5_1<-Heatmap(hyp_CTB_5, heatmap_width = unit(15, "cm"),heatmap_height = unit(15, "cm"),show_row_names = FALSE, show_column_names = FALSE, heatmap_legend_param = list(title = "Adjacency Score"), use_raster = T) #plot the heatmap, specifying the number of column and row clusters to split it into, raster improves performance at cost of resolution
draw(hm_CTB_5_1) #above comand will save the output to an object. use this command to plot the heatmap. plot(hm_FGR_1) also works

#then plot again when you can select the clusters in the data (represented by higher value colours based on the heatmap colourscale)
hm_CTB_5_2<-Heatmap(hyp_CTB_5, heatmap_width = unit(15, "cm"),heatmap_height = unit(15, "cm"),show_row_names = FALSE, show_column_names = FALSE, row_split = 2, column_split = 2, heatmap_legend_param = list(title = "Adjacency Score"),use_raster = T) #plot the heatmap, specifying the number of column and row clusters to split it into, raster improves performance at cost of resolution
ht <- draw(hm_CTB_5_2) #above comand will save the output to an object. 
row_order_CTB_5_2 <- row_order(ht)

# Save the heatmap as a PNG
png("C:/Users/Team Knowhow/OneDrive - The University of Manchester/MScRP2/R/Third_trimester/yang_mitoxall/CTB_5_1_heatmap.png", width = 2300, height = 2000, res = 300)  # 300 dpi for publication quality
draw(hm_CTB_5_1)
dev.off()

# Save the heatmap as a PNG
png("C:/Users/Team Knowhow/OneDrive - The University of Manchester/MScRP2/R/Third_trimester/yang_mitoxall/CTB_5_2_heatmap.png", width = 2300, height = 2000, res = 300)  # 300 dpi for publication quality
draw(hm_CTB_5_2)
dev.off()
```

```{r}
## calculating the galois for the cluster ##

# extract row orders
row_order_CTB_5_2<-row_order(ht) #extract the row order from the heatmap into a list; each list element represents a cluster from the image and the number represents the row from the original data, arranged in the same order as the heatmap.
CTB_5_clust<-rownames(hyp_CTB_5)[row_order_CTB_5_2[[1]]] #extract row names from row numbers extracted in step above.

## calculate the galois correspondacnce
CTB_5_gal<-bin_CTB_5[match(CTB_5_clust,rownames(bin_CTB_5)),] #subset the original binary matrix to the rows from the cluster defined above

gal_98<-CTB_5_gal[,colSums(CTB_5_gal)>quantile(colSums(CTB_5_gal), 0.98)]
write.csv(gal_98, file = "C:/Users/Team Knowhow/OneDrive - The University of Manchester/MScRP2/R/Third_trimester/yang_mitoxall/galois/CTB_5_gal_98.csv", row.names = TRUE)
```

# STB_1 #

```{r}

#### STB_1 ####  
set.seed(3)

# Filter cells by cluster name
STB_1 <- cell_obs[cell_obs$unique_cell_type == "STB_1", ]

# subset X_data by cell IDs only in STB_1
STB_1_X <- X_data[rownames(X_data) %in% rownames(STB_1), ]

# calculate standard deviation for each column (gene) in STB_1 expression data
sd.scores0<-apply(STB_1_X,2,sd) #2 = selects columns not rows
STB_1_X_sd<-STB_1_X[,which(sd.scores0>0)] # only keep genes with SD>0; removes genes with no variation

# idenfity MT genes that are also velocity genes
STB_1_mito <- rownames(gene_var)[gene_var$mito_gene == "True"]

# Run the correlation
STB_1_cor_data <- cor(STB_1_X_sd[, intersect(STB_1_mito, colnames(STB_1_X_sd))], # mito genes   
                      STB_1_X_sd[, !colnames(STB_1_X_sd) %in% STB_1_mito]) # non-mito genes

#Binarise correlation values using sd of correlation matrix
bin_STB_1 <-abs(STB_1_cor_data) # takes absolute value of correlation matrix
bin_STB_1[which(bin_STB_1>sd(STB_1_cor_data))]<-1 # binarises values, where values greater than SD of correlation matrix are set to 1
bin_STB_1[which(bin_STB_1!=1)]<-0 # all other values are set to 0; this creates the hypergraph incidence matrix

#Matrix multiplication to generate hypergraph adjacency matrix
hyp_STB_1<-bin_STB_1 %*% t(bin_STB_1) # adjacency matrix; multiplies the matrix by its transpose

#ranking
STB_1_rowsum_result<- rowSums(hyp_STB_1) # sum each row in adjacency matrix
hist(STB_1_rowsum_result) # histogram of row sums to visualise distribution
STB_1_row_sums <- as.data.frame(STB_1_rowsum_result) # converts row sums vector to a data frame

colnames(STB_1_row_sums)[1] <- "rowsum" # rename column to rowsum
STB_1_row_sums$unique_cell_type <- "STB_1"  # adds a column with cell type label
STB_1_row_sums$rank <- rank(STB_1_row_sums$rowsum, ties.method = "average") # ranks genes based on row sums, using average ranking for tied values 
STB_1_row_sums$norm_rank <- STB_1_row_sums$rank / nrow(STB_1_row_sums) # normalises ranks by dividing by total number of rows, creating a value between 0 and 1

STB_1_row_sums <- STB_1_row_sums[order(STB_1_row_sums$rank, decreasing = TRUE), ] # sorts data frame in descending order of rank

write.csv(STB_1_row_sums, "C:/Users/Team Knowhow/OneDrive - The University of Manchester/MScRP2/R/Third_trimester/yang_mitoxall/STB_1_row_sums_results_ranked.csv", row.names=TRUE)

## plotting the heatmaps ##

#initially plot without row_split = 2,column_split = 2, so you can see your data
hm_STB_1_1<-Heatmap(hyp_STB_1, heatmap_width = unit(15, "cm"),heatmap_height = unit(15, "cm"),show_row_names = FALSE, show_column_names = FALSE, heatmap_legend_param = list(title = "Adjacency Score"), use_raster = T) #plot the heatmap, specifying the number of column and row clusters to split it into, raster improves performance at cost of resolution
draw(hm_STB_1_1) #above comand will save the output to an object. use this command to plot the heatmap. plot(hm_FGR_1) also works

#then plot again when you can select the clusters in the data (represented by higher value colours based on the heatmap colourscale)
hm_STB_1_2<-Heatmap(hyp_STB_1, heatmap_width = unit(15, "cm"),heatmap_height = unit(15, "cm"),show_row_names = FALSE, show_column_names = FALSE, row_split = 2, column_split = 2, heatmap_legend_param = list(title = "Adjacency Score"),use_raster = T) #plot the heatmap, specifying the number of column and row clusters to split it into, raster improves performance at cost of resolution
ht <- draw(hm_STB_1_2) #above comand will save the output to an object. 
row_order_STB_1_2 <- row_order(ht)

# Save the heatmap as a PNG
png("C:/Users/Team Knowhow/OneDrive - The University of Manchester/MScRP2/R/Third_trimester/yang_mitoxall/STB_1_1_heatmap.png", width = 2300, height = 2000, res = 300)  # 300 dpi for publication quality
draw(hm_STB_1_1)
dev.off()

# Save the heatmap as a PNG
png("C:/Users/Team Knowhow/OneDrive - The University of Manchester/MScRP2/R/Third_trimester/yang_mitoxall/STB_1_2_heatmap.png", width = 2300, height = 2000, res = 300)  # 300 dpi for publication quality
draw(hm_STB_1_2)
dev.off()
```

```{r}
## calculating the galois for the cluster ##

# extract row orders
row_order_STB_1_2<-row_order(ht) #extract the row order from the heatmap into a list; each list element represents a cluster from the image and the number represents the row from the original data, arranged in the same order as the heatmap.
STB_1_clust<-rownames(hyp_STB_1)[row_order_STB_1_2[[2]]] #extract row names from row numbers extracted in step above.

## calculate the galois correspondacnce
STB_1_gal<-bin_STB_1[match(STB_1_clust,rownames(bin_STB_1)),] #subset the original binary matrix to the rows from the cluster defined above

gal_98<-STB_1_gal[,colSums(STB_1_gal)>quantile(colSums(STB_1_gal), 0.98)]
write.csv(gal_98, file = "C:/Users/Team Knowhow/OneDrive - The University of Manchester/MScRP2/R/Third_trimester/yang_mitoxall/galois/STB_1_gal_98.csv", row.names = TRUE)
```

# EVT_1 #

```{r}

#### EVT_1 ####  
set.seed(3)

# Filter cells by cluster name
EVT_1 <- cell_obs[cell_obs$unique_cell_type == "EVT_1", ]

# subset X_data by cell IDs only in EVT_1
EVT_1_X <- X_data[rownames(X_data) %in% rownames(EVT_1), ]

# calculate standard deviation for each column (gene) in EVT_1 expression data
sd.scores0<-apply(EVT_1_X,2,sd) #2 = selects columns not rows
EVT_1_X_sd<-EVT_1_X[,which(sd.scores0>0)] # only keep genes with SD>0; removes genes with no variation

# idenfity MT genes that are also velocity genes
EVT_1_mito <- rownames(gene_var)[gene_var$mito_gene == "True"]

# Run the correlation
EVT_1_cor_data <- cor(EVT_1_X_sd[, intersect(EVT_1_mito, colnames(EVT_1_X_sd))], # mito genes   
                      EVT_1_X_sd[, !colnames(EVT_1_X_sd) %in% EVT_1_mito]) # non-mito genes

#Binarise correlation values using sd of correlation matrix
bin_EVT_1 <-abs(EVT_1_cor_data) # takes absolute value of correlation matrix
bin_EVT_1[which(bin_EVT_1>sd(EVT_1_cor_data))]<-1 # binarises values, where values greater than SD of correlation matrix are set to 1
bin_EVT_1[which(bin_EVT_1!=1)]<-0 # all other values are set to 0; this creates the hypergraph incidence matrix

#Matrix multiplication to generate hypergraph adjacency matrix
hyp_EVT_1<-bin_EVT_1 %*% t(bin_EVT_1) # adjacency matrix; multiplies the matrix by its transpose

#ranking
EVT_1_rowsum_result<- rowSums(hyp_EVT_1) # sum each row in adjacency matrix
hist(EVT_1_rowsum_result) # histogram of row sums to visualise distribution
EVT_1_row_sums <- as.data.frame(EVT_1_rowsum_result) # converts row sums vector to a data frame

colnames(EVT_1_row_sums)[1] <- "rowsum" # rename column to rowsum
EVT_1_row_sums$unique_cell_type <- "EVT_1"  # adds a column with cell type label
EVT_1_row_sums$rank <- rank(EVT_1_row_sums$rowsum, ties.method = "average") # ranks genes based on row sums, using average ranking for tied values 
EVT_1_row_sums$norm_rank <- EVT_1_row_sums$rank / nrow(EVT_1_row_sums) # normalises ranks by dividing by total number of rows, creating a value between 0 and 1

EVT_1_row_sums <- EVT_1_row_sums[order(EVT_1_row_sums$rank, decreasing = TRUE), ] # sorts data frame in descending order of rank

write.csv(EVT_1_row_sums, "C:/Users/Team Knowhow/OneDrive - The University of Manchester/MScRP2/R/Third_trimester/yang_mitoxall/EVT_1_row_sums_results_ranked.csv", row.names=TRUE)

## plotting the heatmaps ##

#initially plot without row_split = 2,column_split = 2, so you can see your data
hm_EVT_1_1<-Heatmap(hyp_EVT_1, heatmap_width = unit(15, "cm"),heatmap_height = unit(15, "cm"),show_row_names = FALSE, show_column_names = FALSE, heatmap_legend_param = list(title = "Adjacency Score"), use_raster = T) #plot the heatmap, specifying the number of column and row clusters to split it into, raster improves performance at cost of resolution
draw(hm_EVT_1_1) #above comand will save the output to an object. use this command to plot the heatmap. plot(hm_FGR_1) also works

#then plot again when you can select the clusters in the data (represented by higher value colours based on the heatmap colourscale)
hm_EVT_1_2<-Heatmap(hyp_EVT_1, heatmap_width = unit(15, "cm"),heatmap_height = unit(15, "cm"),show_row_names = FALSE, show_column_names = FALSE, row_split = 2, column_split = 2, heatmap_legend_param = list(title = "Adjacency Score"),use_raster = T) #plot the heatmap, specifying the number of column and row clusters to split it into, raster improves performance at cost of resolution
ht <- draw(hm_EVT_1_2) #above comand will save the output to an object. 
row_order_EVT_1_2 <- row_order(ht)

# Save the heatmap as a PNG
png("C:/Users/Team Knowhow/OneDrive - The University of Manchester/MScRP2/R/Third_trimester/yang_mitoxall/EVT_1_1_heatmap.png", width = 2300, height = 2000, res = 300)  # 300 dpi for publication quality
draw(hm_EVT_1_1)
dev.off()

# Save the heatmap as a PNG
png("C:/Users/Team Knowhow/OneDrive - The University of Manchester/MScRP2/R/Third_trimester/yang_mitoxall/EVT_1_2_heatmap.png", width = 2300, height = 2000, res = 300)  # 300 dpi for publication quality
draw(hm_EVT_1_2)
dev.off()
```

```{r}
## calculating the galois for the cluster ##

# extract row orders
row_order_EVT_1_2<-row_order(ht) #extract the row order from the heatmap into a list; each list element represents a cluster from the image and the number represents the row from the original data, arranged in the same order as the heatmap.
EVT_1_clust<-rownames(hyp_EVT_1)[row_order_EVT_1_2[[2]]] #extract row names from row numbers extracted in step above.

## calculate the galois correspondacnce
EVT_1_gal<-bin_EVT_1[match(EVT_1_clust,rownames(bin_EVT_1)),] #subset the original binary matrix to the rows from the cluster defined above

gal_98<-EVT_1_gal[,colSums(EVT_1_gal)>quantile(colSums(EVT_1_gal), 0.98)]
write.csv(gal_98, file = "C:/Users/Team Knowhow/OneDrive - The University of Manchester/MScRP2/R/Third_trimester/yang_mitoxall/galois/EVT_1_gal_98.csv", row.names = TRUE)
```

